컴퓨터 시스템의 구성: 응용 소프트웨어, 시스템 소프트웨어. 하드웨어
하드웨어: 컴퓨터 정보들의 전송 통로를 제공, 그 정보에 대한 처리가 실제 일어나게 해주는 물리적인 실체들
소프트웨어: 정보들이 이동하는 방향과 정보 처리의 종류 지정, 그러한 동작 일어나는 시간 지정하는 명령어의 집합
기계어: 기계코드로 컴퓨터 하드웨어 부품들이 이해할 수 있는 언어, 2진 비트로 구성
어셈블리 언어: 고급언어~기계어 사이의 언어, 어셈블러를 통해 기계어로 번역됨
 ㄴ 니모닉스: 어셈블리 명령어가 지정하는 연산 가리키는 알파벳 기호. (LOAD, ADD..)
고급 언어: C,C++등의 언어, 컴파일러를 통해 기계어로 번역됨. 
연산코드: CPU가 수행할 연산 지정해주는 비트들
오퍼랜드: 연산에 사용될 데이터 혹은 그것이 저장되어 있는 기억장치 주소
단어: 각 기억 장소에 저장되는 정보의 기본 단위, CPU에 의해 한 번에 처리될 수 있는 비트들의 그룹
주소지정단위: 단어, byte
시스템 버스: CPU와 시스템 내의 다른 요소들 사이에 정보를 교환하는 통로
- 주소버스: CPU가 외부로 발생하는 주소 정보를 전송하는 신호 선들의 집합 / 단방향성
- 데이터버스: CPU가 기억장치 혹은 I/O장치 사이에 데이터를 전송하기 위한 신호선의 집합 / 양
- 제어버스: CPU가 시스템 내의 동작을 제어하기 위한 신호선들의 집합 / 양방향성 
   ㄴ 읽기신호, 쓰기 신호
I/O장치제어기: 상태레지스터 읽음 -> In_RDY? = 1 -> 데이터레지스터 읽음
트랜지스터: 초기 전자식 컴퓨터의 핵심 부품인 진공관을 대체한 전자부품
집적 회로(IC): 수만 개 이상의 트랜지스터들을 하나의 반도체 칩에 집적시킨 전자부품, 3세대 핵심
SSI: 수십 개의 트랜지스터들이 집적되는 소규모 IC
MSI: 수백 개의 트랜지스터 집적되는 IC / 시프트레지스터와 같은 조합.순차 회로 포함
LSI: 수천 개의 트랜지스터 집적됨 
VLSI: 수만~수십만개 트랜지스터, 제 4세개 핵심 (개인용 컴퓨터 등의 출현)
ULSI: 수백만 개 이상의 트랜지스터들이 집적
개인용 컴퓨터
임베디드 컴퓨터: 폰, 비디오 게임기 등..
슈퍼컴퓨터
대규모 병렬컴퓨터
클러스터 컴퓨터

명령어 인출(IF): 기억장치로부터 명령어를 읽어온다. (필)
명령어 해독(ID): 수행해야할 동작을 결정하기 위해 명령어를 해독. (필)
데이터 인출(DF): 명령어 실행을 위해 데이터가 필요한 경우 기억장치 혹은 I/O장치로부터 데이터 읽어옴
데이터 처리(DP): 데이터에 대한 산술적 혹은 논리적 연산을 수행
데이터 저장(DS): 수행한 결과를 저장
CPU 기본 구조: 산술논리연산장치, 레지스터 세트, 제어 유니트
CPU내부버스: CPU내부에서 위 세 개를 연결해주는 버스(시스템버스와는 별개.. )
명령어 사이클: CPU가 한 개의 명령어를 실행하는데 필요한 전체 처리 과정으로서, CPU가 프로그램 실행을 시작한 순간부터 종료될때까지 반복
사이클은 두 개의 부사이클로 분리함
- 인출사이클: CPU가 기억장치로부터 명령어를 읽어오는 단계
- 실행 사이클: 명령어를 실행하는 단계
레지스터 세트(5개)
프로그램 카운터(PC): 다음에 인출할 명령어의 주소를 가지고 있는 레지스터 
누산기(AC): 데이터를 일시적으로 저장하는 레지스터 
명령어 레지스터(IR): 가장 최근에 인출된 명령어 코드가 저장되어 있는 레지스터 
기억장치 주소 레지스터(MAR): PC에 저장된 명령어 주소가 시스템 주소 버스로 출력되기 전에 일시적으로 저장되는 레지스터
기억장치 버퍼 레지스터(MBR): 기억장치에 쓰여질 데이터 혹은 기억장치로부터 읽혀진 데이터를 일시적으로 저장하는 버퍼 레지스터
인출사이클 마이크로 연산, LOAD, ADD, STA, JUMP
인터럽트: 프로그램 실행 중에 CPU의 현재 처리 순서를 중단시키고 다른 동작을 수행하도록 요구하는 동작
인터럽트 서비스 루틴 = ISR
간접사이클: 명령어에 포함돼 있는 주소 이용해 명령어 실행에 필요한 주소 인출하는 사이클(간접주소지정)

명령어 파이프라이닝: CPU의 처리 속도를 높이기 위해 CPU 내부 하드웨어를 여러 단계로 나누어 동시에 처리하는 기술
2-단계 명령어 파이프라이닝: 인출단계, 실행단계
4-단계 명령어 파이프라이닝: 명령어 인출단계, 명령어 해독 단계, 오퍼랜드 인출단계, 실행단계 
파이프라인의 효율저하 요인들
1. 모든 명령어들이 파이프라인 단계들을 모두 거치지는 않음
2. 파이프라인의 클럭은 처리시간이 가장 오래걸리는 단계 기준으로 결정
3. IF단계와 OF단계가 동시에 기억장치를 액세스 하는 경우에, 기억장치 충돌이 일어나면 지연이 발생
4. 조건 분기 명령어가 실행되면, 미리 인출하여 처리하던 명령어들이 무효화됨 
상태 레지스터: 조건분기 명령어가 사용할 조건 플래그 들을 저장
S(부호플래그): 음수시 1
Z(제로플래그): 연산값 0일시 1
C(캐리플래그): 캐리나 빌림수 발생시 1
X
E(동등플래그): 비교시 같으면 1
V(오버플로우플래그): 오버플로우 발생시1
I(인터럽트플래그): 인터럽트 불가능 상태면 1
P(슈퍼바이저플래그): CPU상태 슈퍼바이저 모드면 1, 사용자 모드면 0 
슈퍼스칼라
CPU코어: 명령어 실행에 필요한 CPU 내부의 핵심 하드웨어 모듈(ALU, 레지스터 등)
멀티-코어 프로세서: 여러 개의 CPU 코어들을 하나의 칩에 포함시킨 프로세서
EX) 듀얼코어, 쿼드코어, 헥사코어, 옥타코어
듀얼-코어 프로세서: 단일코어 슈퍼스칼라 프로세서에 비해 2배 속도 향상 -> 멀티태스킹, 멀티스레딩 지원
멀티 스레딩
스레드: 독립적으로 실행될 수 있는 최소 크기의 프로그램 단위

명령어 세트: 연산종류, 명령어 형식, 주소지정 방식
연산 종류: 데이터 전송, 산술연산, 논리연산, 입출력, 프로그램 제어
CALL명령어: 현재의 PC내용을 스택에 저장하고 서브루틴의 시작 주소 분기하는 명령어
RET명령어: CPU가 원래 실행하던 프로그램으로 복귀 시키는 명령어
연산코드, 오퍼랜드(1~2개의 입력 오퍼랜드와 1개의 결과 오퍼랜드)
다음 명령어 주소: 현재의 명령어 실행이 완료된 후에 다음 명령어를 인출할 위치 지정 
명령어 형식: 명령어 내 필드들의 수와 배치 방식 및 각 필드의 비트 수
필드: 명령어의 각 구성 요소들에 소요되는 비트들의 그룹 
명령어의 길이: 단어의 길이
연산 코드 필드 길이: 연산의 개수를 지정
오퍼랜드 종류: 
-데이터:명령어의 오퍼랜드 필드에 데이터 포함 
   ㄴ 오퍼랜드 2보수 -> -2^11~2^11 / 오퍼랜드 기억장치 주소일땐 -> 2^12
-기억장치 주소:데이터가 저장된 기억장치의 위치 지정
   ㄴ 0~2^n - 1번지까지 저장 가능
-레지스터 번호: 데이터가 저장된 레지스터 지정
   ㄴ 2^n 개 사용가능. 
1주소명령어: 오퍼랜드를 한 개만 포함하는 명령어(다른 오퍼랜드는 묵시적으로 AC가 됨. )
2,3도 마찬가지. (R1, R2...)
주소지정방식 사용이유: 여러가지 방법으로 오퍼랜드의 주소를 결정하도록해주며 더 큰 용량의 기억장치 사용할 수 있도록
주소지정방식의종류 / 기억장치 액세스 횟수
1. 직접 주소지정 방식 EA = A -> 인출1회, 실행1회
장점: 데이터 인출을 위해 한 번의 기억장치 액세스만 필요
단점: 지정할 수 있는 기억장치 수 제한
2. 간접 주소 지정 방식 EA = (A) -> 인출1회, 실행2회
장점: 최대 기억장치용량이 단어의 길이에 의해 결정 -> 주소지정 가능한 기억장치 용량 늘어남(2^n)
단점: 실행사이클 동안에 두 번의 기억장치 액세스 필요
3. 즉시 주소 지정 방식 -> 인출1회
4. 레지스터 주소 지정 방식 EA = R -> 인출 1회
장점: 오퍼랜드 필드의 비트수 적어도 됨, 데이터 인출시 기억장치 액세스 필요 없다. 
단점: 데이터가 저장될 수 있는 공간이 CPU내부 레지스터들로 제한
5. 간접 레지스터 주소 지정 방식 EA = (R) -> 인출 1회, 실행 1회
장점: 주소 지정할 수 있는 기억장치 영역 확장 -> 레지스터 길이 16비트라면 주소지정 영역 2^16
6. 변위 주소 지정 방식: 직접 주소지정과 레지스터 간접 주소지정 방식의 조합 
- 상대 주소 지정 방식 EA = A + (PC) -> 인출 1회, 실행 1회
장점: 전체 기억장치 주소가 명령어에 포함되어야 하는 일반적인 분기 명령어 보다 적은 수의 비트 필요
단점: 분기 범위가 오퍼랜드 필드의 길이에 의해 제한
- 인덱스 주소 지정 방식 EA = A + (IX) -> 인출 1회, 실행 1회
자동 인덱싱: 명령어가 실행될 때마다 인덱스 레지스터의 내용이 자동적으로 증가 혹은 감소
CISC프로세서: 명령어들의 수가 많음, 명령어 길이가 일정하지 않음, 주소지정 방식이 매우 다양함 
RISC프로세서: 명령어들의 수를 최소화, 명령어 길이를 일정하게 고정, 주소지정 방식의 종류 단순화
PDP-10프로세서: 단어길이 36bit, 명령어 길이 36bit 
ㄴ 연산코드(9bit) | 레지스터(4) | 간접비트(1) | 인덱스 레지스터(4) | 기억장치 주소(18) = 36bit
PDP-11프로세서: 다양한 길이의 명령어 형식들 사용
위처럼 고정되어있지 않고, 연산코드 -> 4~16bit / 주소 개수: 0,1,2개 사용

산술 연산장치: 산술연산(+,-,/,*) -> 입력데이터
논리 연산장치: 논리 연산들(AND, OR, XOR, NOT) -> 입력데이터
시프트 레지스터: 비트들을 좌측 혹은 우측으로 이동시키는 기능을 가진 레지스터 -> 출력데이터
보수기: 2진 데이터를 2의 보수로 변환(음수화) -> 플래그들
상태 레지스터: 연산 결과의 상태를 나타내는 플래그들을 저장하는 레지스터 -> 제어 신호들
이진수를 음수로 표현하는 방법
1. 부호화크기표현법
2. 1의보수 표현법 -> -2^(n-1)+1 ~ 2^(n-1)-1
3. 2의 보수 표현법 -> 2^(n-1) ~ 2^(n-1)-1 (표현가능 수 하나 더 많음)
2보수 -> 10진수 = 2보수를 2보수 취해준 뒤 음수 붙임 = 10진수
컴퓨터는 2의 보수 표현법 사용.. 가산기 하나만으로 덧셈과 뺄셈 가능
비트확장: 데이터를 더 많은 비트의 레지스터에 저장하거나, 더 긴 데이터와 연산 수행하기 위해..
부호화 크기 표현법
양수 -> 00000000 00001111 음수 -> 10000000 00001111
2의 보수 표현법
양수 -> 00000000 00001111 음수 -> 11111111 11110001
선택적 세트연산: 1로 세트해줌 / OR연산
선택적 보수연산: 보수로 세트해줌 / XOR연산
mask연산: 레지스터의 비트들을 0으로 바꾸는 연산 / AND연산
삽입 연산: 새로운 비트 값들을 데이터 단어 내의 특정 위치에 삽입 / AND 후 OR
비교연산: 비교해줌 / XOR연산 -> 모두 같으면 Z플래그 1로 세트함
논리적 시프트 -> 좌측 시프트, 우측시프트
순환 논리적 시프트 -> 순환 좌측시프트, 순환 우측시프트
직렬 데이터 전송: N비트만큼 시프트연산 수행하여 전체 데이터 이동시킴 
산술적 시프트: 부호 비트는 그대로 유지시키고 수의 크기를 나타내는 비트들만 시프트
-> 산술적 좌측 시프트(ASL) = 원래 값의 2배
-> 산술적 우측 시프트 (ASR) = 원래 값의 1/2배 그러나 홀수계산의 경우 0.5손실
C플래그를 포함한 좌측 시프트 -> SHLC / SHRC
C플래그를 포함한 순환 좌측 시프트 -> RLC / RRC

2보수의 덧셈 -> 올림수 발생시 버림
병렬 가산기: 덧셈을 수행하는 하드웨어 모듈 (C, S, Z, V)
부동 소수점 표현: 수 표현 범위 확대 가능
부동 소수점 수의 일반적 형태 
N = (-1)^s M*B^E
S = 부호 / M = 가수(정밀도 증가) / B = 기수 / E = 지수(증가시 표현 가능한 수 범위 확장)
단일 정밀도 = 32비트
복수 정밀도 = 64비트
정규화된 표현 -> +-0.1xxx...x * 2^E
바이어스된 수 -> 지수(E)표현시 사용 
: 모든 비트들 0되도록 함으로써 0-검사 용이하게 하기 위함 
IEEE 754표준 부동 소수점
32bit -> N = (-1)^s*2^(E-127)
64bit -> N = (-1)^s*2^(E-1023)
ㄴ 정규화 -> +-1.xxx...x * 2^E
2진수 부동소수점 곱셈
1. 가수 곱함
2. 지수 더함
3. 결과값 정규화
2진수 부동소수점 나눗셈
1. 가수 나눔
2. 피제수의 지수에서 제수의 지수 뺸다.
3. 결과값 정규화 
